{"version":3,"file":"use-combine-values-DXlfacMq.js","sources":["../../../node_modules/framer-motion/dist/es/value/use-motion-value.mjs","../../../node_modules/framer-motion/dist/es/value/use-combine-values.mjs"],"sourcesContent":["import { useContext, useState, useEffect } from 'react';\nimport { motionValue } from './index.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n","import { useMotionValue } from './use-motion-value.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nimport { cancelFrame, frame } from '../frameloop/frame.mjs';\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    const value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    const updateValue = () => value.set(combineValues());\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useIsomorphicLayoutEffect(() => {\n        const scheduleUpdate = () => frame.preRender(updateValue, false, true);\n        const subscriptions = values.map((v) => v.on(\"change\", scheduleUpdate));\n        return () => {\n            subscriptions.forEach((unsubscribe) => unsubscribe());\n            cancelFrame(updateValue);\n        };\n    });\n    return value;\n}\n\nexport { useCombineMotionValues };\n"],"names":["useMotionValue","initial","value","useConstant","motionValue","isStatic","useContext","MotionConfigContext","setLatest","useState","useEffect","useCombineMotionValues","values","combineValues","updateValue","useIsomorphicLayoutEffect","scheduleUpdate","frame","subscriptions","v","unsubscribe","cancelFrame"],"mappings":"iHAsBA,SAASA,EAAeC,EAAS,CAC7B,MAAMC,EAAQC,EAAY,IAAMC,EAAYH,CAAO,CAAC,EAM9C,CAAE,SAAAI,CAAQ,EAAKC,EAAU,WAACC,CAAmB,EACnD,GAAIF,EAAU,CACV,KAAM,EAAGG,CAAS,EAAIC,EAAQ,SAACR,CAAO,EACtCS,EAAS,UAAC,IAAMR,EAAM,GAAG,SAAUM,CAAS,EAAG,EAAE,CACzD,CACI,OAAON,CACX,CC/BA,SAASS,EAAuBC,EAAQC,EAAe,CAInD,MAAMX,EAAQF,EAAea,GAAe,EAOtCC,EAAc,IAAMZ,EAAM,IAAIW,EAAa,CAAE,EAKnD,OAAAC,EAAa,EAKbC,EAA0B,IAAM,CAC5B,MAAMC,EAAiB,IAAMC,EAAM,UAAUH,EAAa,GAAO,EAAI,EAC/DI,EAAgBN,EAAO,IAAKO,GAAMA,EAAE,GAAG,SAAUH,CAAc,CAAC,EACtE,MAAO,IAAM,CACTE,EAAc,QAASE,GAAgBA,EAAW,CAAE,EACpDC,EAAYP,CAAW,CAC1B,CACT,CAAK,EACMZ,CACX","x_google_ignoreList":[0,1]}